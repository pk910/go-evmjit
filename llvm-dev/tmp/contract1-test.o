; ModuleID = 'contract1-test.ll'
source_filename = "contract1-test.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%struct.evm_stack = type { i8*, i64 }

@const_zero32 = local_unnamed_addr constant [32 x i8] zeroinitializer
@const_data1 = local_unnamed_addr constant [6 x i8] c"333333"
@const_data2 = local_unnamed_addr constant [8 x i8] c"\11\11\11\11\11\11\11\11"

; Function Attrs: argmemonly mustprogress nofree nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define i32 @test(%struct.evm_stack* nocapture noundef %stack) local_unnamed_addr #1 {
entry:
  %stack_ptr = getelementptr %struct.evm_stack, %struct.evm_stack* %stack, i64 0, i32 0
  %stack_addr = load i8*, i8** %stack_ptr, align 8
  %stack_position_ptr = getelementptr %struct.evm_stack, %struct.evm_stack* %stack, i64 0, i32 1
  %l1_2 = load i64, i64* %stack_position_ptr, align 8
  %l1_3 = getelementptr inbounds i8, i8* %stack_addr, i64 %l1_2
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(26) %l1_3, i8 0, i64 26, i1 false)
  %l1_5 = getelementptr i8, i8* %l1_3, i64 26
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(6) %l1_5, i8 51, i64 6, i1 false)
  %l1_6 = add i64 %l1_2, 32
  %l2_3 = getelementptr inbounds i8, i8* %stack_addr, i64 %l1_6
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(24) %l2_3, i8 0, i64 24, i1 false)
  %l2_5 = getelementptr i8, i8* %l2_3, i64 24
  %0 = bitcast i8* %l2_5 to i64*
  store i64 1229782938247303441, i64* %0, align 1
  %l2_6 = add i64 %l1_2, 64
  store i64 %l2_6, i64* %stack_position_ptr, align 8
  %l3_2 = getelementptr inbounds i8, i8* %stack_addr, i64 %l2_6
  %l3_6 = getelementptr inbounds i8, i8* %l3_2, i64 -32
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(32) %l3_2, i8* noundef nonnull align 1 dereferenceable(32) %l3_6, i64 32, i1 false)
  %l3_7 = add i64 %l1_2, 96
  store i64 %l3_7, i64* %stack_position_ptr, align 8
  %l4_2 = alloca [32 x i8], align 16
  %l4_3 = getelementptr inbounds i8, i8* %stack_addr, i64 %l3_7
  %l4_4 = getelementptr inbounds i8, i8* %l4_3, i64 -32
  %l4_8 = getelementptr inbounds i8, i8* %l4_4, i64 -64
  %l4_9 = getelementptr inbounds [32 x i8], [32 x i8]* %l4_2, i64 0, i64 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 16 dereferenceable(32) %l4_9, i8* noundef nonnull align 1 dereferenceable(32) %l4_4, i64 32, i1 false)
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(32) %l4_4, i8* noundef nonnull align 1 dereferenceable(32) %l4_8, i64 32, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(32) %l4_8, i8* noundef nonnull align 16 dereferenceable(32) %l4_9, i64 32, i1 false)
  %l5_1 = load i64, i64* %stack_position_ptr, align 8
  %l5_2 = getelementptr inbounds i8, i8* %stack_addr, i64 %l5_1
  %l5_aptr = getelementptr inbounds i8, i8* %l5_2, i64 -32
  %l5_bptr = getelementptr inbounds i8, i8* %l5_aptr, i64 -32
  %l5_aptr1 = bitcast i8* %l5_aptr to i64*
  %l5_bptr1 = bitcast i8* %l5_bptr to i64*
  %l5_afof4 = getelementptr inbounds i8, i8* %l5_aptr, i64 24
  %l5_aptr4 = bitcast i8* %l5_afof4 to i64*
  %l5_aval4 = load i64, i64* %l5_aptr4, align 8
  %l5_bfof4 = getelementptr inbounds i8, i8* %l5_bptr, i64 24
  %l5_bptr4 = bitcast i8* %l5_bfof4 to i64*
  %l5_bval4 = load i64, i64* %l5_bptr4, align 8
  %l5_res4 = add i64 %l5_bval4, %l5_aval4
  %l5_res4c1 = icmp ult i64 %l5_res4, %l5_aval4
  %l5_res4c2 = icmp ult i64 %l5_res4, %l5_bval4
  %l5_res4co = or i1 %l5_res4c1, %l5_res4c2
  %l5_res4c = zext i1 %l5_res4co to i64
  store i64 %l5_res4, i64* %l5_aptr4, align 8
  %l5_afof3 = getelementptr inbounds i8, i8* %l5_aptr, i64 16
  %l5_aptr3 = bitcast i8* %l5_afof3 to i64*
  %l5_aval3 = load i64, i64* %l5_aptr3, align 8
  %l5_bfof3 = getelementptr inbounds i8, i8* %l5_bptr, i64 16
  %l5_bptr3 = bitcast i8* %l5_bfof3 to i64*
  %l5_bval3 = load i64, i64* %l5_bptr3, align 8
  %l5_res3p = add i64 %l5_bval3, %l5_aval3
  %l5_res3 = add i64 %l5_res3p, %l5_res4c
  %l5_res3c1 = icmp ult i64 %l5_res3, %l5_aval3
  %l5_res3c2 = icmp ult i64 %l5_res3, %l5_bval3
  %l5_res3c3 = or i1 %l5_res3c1, %l5_res3c2
  %l5_res3c4 = icmp eq i64 %l5_res3, %l5_aval3
  %l5_res3c5 = icmp ne i64 %l5_bval3, 0
  %l5_res3c6 = and i1 %l5_res3c5, %l5_res3c4
  %l5_res3c7 = or i1 %l5_res3c3, %l5_res3c6
  %l5_res3c = zext i1 %l5_res3c7 to i64
  store i64 %l5_res3, i64* %l5_aptr3, align 8
  %l5_afof2 = getelementptr inbounds i8, i8* %l5_aptr, i64 8
  %l5_aptr2 = bitcast i8* %l5_afof2 to i64*
  %l5_aval2 = load i64, i64* %l5_aptr2, align 8
  %l5_bfof2 = getelementptr inbounds i8, i8* %l5_bptr, i64 8
  %l5_bptr2 = bitcast i8* %l5_bfof2 to i64*
  %l5_bval2 = load i64, i64* %l5_bptr2, align 8
  %l5_res2p = add i64 %l5_bval2, %l5_aval2
  %l5_res2 = add i64 %l5_res2p, %l5_res3c
  %l5_res2c1 = icmp ult i64 %l5_res2, %l5_aval2
  %l5_res2c2 = icmp ult i64 %l5_res2, %l5_bval2
  %l5_res2c3 = or i1 %l5_res2c1, %l5_res2c2
  %l5_res2c4 = icmp eq i64 %l5_res2, %l5_aval2
  %l5_res2c5 = icmp ne i64 %l5_bval2, 0
  %l5_res2c6 = and i1 %l5_res2c5, %l5_res2c4
  %l5_res2c7 = or i1 %l5_res2c3, %l5_res2c6
  %l5_res2c = zext i1 %l5_res2c7 to i64
  store i64 %l5_res2, i64* %l5_aptr2, align 8
  %l5_aval1 = load i64, i64* %l5_aptr1, align 8
  %l5_bval1 = load i64, i64* %l5_bptr1, align 8
  %l5_res1p = add i64 %l5_bval1, %l5_aval1
  %l5_res1 = add i64 %l5_res1p, %l5_res2c
  store i64 %l5_res1, i64* %l5_aptr1, align 8
  %l5_sdv = add i64 %l5_1, -1
  store i64 %l5_sdv, i64* %stack_position_ptr, align 8
  %l6_2 = getelementptr inbounds i8, i8* %stack_addr, i64 %l5_sdv
  %l6_aptr = getelementptr inbounds i8, i8* %l6_2, i64 -32
  %l6_bptr = getelementptr inbounds i8, i8* %l6_aptr, i64 -32
  %l6_aptr1 = bitcast i8* %l6_aptr to i64*
  %l6_afof4 = getelementptr inbounds i8, i8* %l6_aptr, i64 24
  %l6_aptr4 = bitcast i8* %l6_afof4 to i64*
  %l6_aval4 = load i64, i64* %l6_aptr4, align 8
  %l6_bfof4 = getelementptr inbounds i8, i8* %l6_bptr, i64 24
  %l6_bptr4 = bitcast i8* %l6_bfof4 to i64*
  %l6_bval4 = load i64, i64* %l6_bptr4, align 8
  %l6_res4 = sub i64 %l6_aval4, %l6_bval4
  %l6_17 = icmp ult i64 %l6_aval4, %l6_bval4
  store i64 %l6_res4, i64* %l6_aptr4, align 8
  %l6_afof3 = getelementptr inbounds i8, i8* %l6_aptr, i64 16
  %l6_aptr3 = bitcast i8* %l6_afof3 to i64*
  %l6_aval3 = load i64, i64* %l6_aptr3, align 8
  %l6_bfof3 = getelementptr inbounds i8, i8* %l6_bptr, i64 16
  %l6_bptr3 = bitcast i8* %l6_bfof3 to i64*
  %l6_bval3 = load i64, i64* %l6_bptr3, align 8
  %l6_cmp1 = icmp ult i64 %l6_aval3, %l6_bval3
  br i1 %l6_cmp1, label %l6_cmp1_f, label %l6_cmp1_t

l6_cmp1_t:                                        ; preds = %entry
  %l6_cmp2 = icmp eq i64 %l6_aval3, %l6_bval3
  %l6_27 = select i1 %l6_cmp2, i1 %l6_17, i1 false
  br label %l6_cmp1_f

l6_cmp1_f:                                        ; preds = %l6_cmp1_t, %entry
  %l6_29 = phi i1 [ true, %entry ], [ %l6_27, %l6_cmp1_t ]
  %l6_30.neg1 = sext i1 %l6_17 to i64
  %l6_31.neg = add i64 %l6_aval3, %l6_30.neg1
  %l6_32 = sub i64 %l6_31.neg, %l6_bval3
  %l6_33 = bitcast i8* %l6_bptr to i64*
  %l6_34.neg2 = sext i1 %l6_29 to i64
  store i64 %l6_32, i64* %l6_aptr3, align 8
  %l6_afof2 = getelementptr inbounds i8, i8* %l6_aptr, i64 8
  %l6_aptr2 = bitcast i8* %l6_afof2 to i64*
  %l6_aval2 = load i64, i64* %l6_aptr2, align 8
  %l6_bfof2 = getelementptr inbounds i8, i8* %l6_bptr, i64 8
  %l6_bptr2 = bitcast i8* %l6_bfof2 to i64*
  %l6_bval2 = load i64, i64* %l6_bptr2, align 8
  %l6_41.neg = add i64 %l6_aval2, %l6_34.neg2
  %l6_42 = sub i64 %l6_41.neg, %l6_bval2
  %l6_43 = icmp ult i64 %l6_aval2, %l6_bval2
  %l6_44 = icmp eq i64 %l6_aval2, %l6_bval2
  %l6_45 = select i1 %l6_44, i1 %l6_29, i1 false
  %l6_46 = select i1 %l6_43, i1 true, i1 %l6_45
  %l6_47.neg3 = sext i1 %l6_46 to i64
  store i64 %l6_42, i64* %l6_aptr2, align 8
  %l6_48 = load i64, i64* %l6_aptr1, align 8
  %l6_49 = load i64, i64* %l6_33, align 8
  %l6_50.neg = sub i64 %l6_48, %l6_49
  %l6_51 = add i64 %l6_50.neg, %l6_47.neg3
  store i64 %l6_51, i64* %l6_aptr1, align 8
  %l6_sdv = add i64 %l5_1, -2
  store i64 %l6_sdv, i64* %stack_position_ptr, align 8
  ret i32 0
}

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2

attributes #0 = { argmemonly mustprogress nofree nounwind willreturn }
attributes #1 = { mustprogress nofree nosync nounwind willreturn }
attributes #2 = { argmemonly nofree nounwind willreturn writeonly }
